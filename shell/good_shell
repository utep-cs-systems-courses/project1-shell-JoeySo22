#! /usr/bin/env python3

'''
    Author: Jose Eduardo Soto
    This is a good shell that uses fork, exec, and wait. This program is written without
    modulating subroutings or methods. It is enough to make a script for now.
'''

import re, sys, os

good_shell_label = ''
running = True

while running:
    # Get input first
    good_shell_label = '%s [%s] %s' % (os.environ['USER'], os.environ['PWD'], '$gs$ ')
    keyboard = input(good_shell_label)
    keyboard = keyboard.split()
    if not keyboard:
        pass
    if keyboard[0].lower() == 'exit':
        os.write(2, ('Exiting GoodShell.\n').encode())
        running = False
        sys.exit(0)
        break
    # Make the pipes
    #pipe_read, pipe_write = os.pipe()
    # Make a child process with fork
    rc = os.fork()
    # Fork fails
    if rc < 0:
        os.write(2, ('Could not fork process. Error Code:\t%d' % rc).encode())
        sys.exit(1)
    # Fork successful. Has its own virtual memory. RC is zero so it is child
    elif rc == 0:
        if '>' in keyboard:
            keyboard.remove('>')
            os.close(1) # cut off display from output
            os.open(keyboard[1], os.O_CREAT | os.O_WRONLY) # open file
            os.set_inheritable(1, True)
            del keyboard[1]
        if '|' in keyboard:
            pass # insert piping functionality here.
        # Go through each directory in os path to find each program
        for dir in re.split(':', os.environ['PATH']):
            # Execute the commands given with exec()
            executable = '%s/%s' % (dir, keyboard[0])
            try:
                os.execve(executable, keyboard, os.environ)
            except FileNotFoundError:
                pass
        os.write(1, ('%s: command not found (gs)\n' % keyboard[0]).encode())
        sys.exit(-1)
    else:
        # Wait until child process dies.
        wait_rc = os.wait()
