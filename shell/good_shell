#! /usr/bin/env python3

'''
    Author: Jose Eduardo Soto
    This is a good shell that uses fork, exec, and wait. This program is written without
    modulating subroutings or methods. It is enough to make a script for now.
'''

import re, sys, os


'''
Parse help from f20_os teams
'''
def parse_command(cmd_string):
    out_file = None
    in_file = None
    cmd = ''

    cmd_string = sub(' +', ' ', cmd_string)

    if '>' in cmd_string:
        [cmd, out_file] = cmd_string.split('>', 1)
        out_file = out_file.strip()

    if '<' in cmd:
        [cmd, in_file] = cmd.split('<', 1)
        in_file = in_file.strip()

    elif out_file != None and '<' in out_file:
        [out_file, in_file] = out_file.split('<', 1)
        out_file = out_file.strip()
        in_file = in_file.strip()

    return cmd.split(), out_file, in_file

def parse_pipe_command(cmd_string):
    if '|' in cmd_string:
        [first_cmd, second_cmd] = cmd_string.split('|', 1)
        first_cmd = first_cmd.strip()
        second_cmd = second_cmd.strip()
        return first_cmd, second_cmd
    else: return None, None


running = True


while running:

    '''
    Get input first
    '''
    keyboard = input()
    keyboard = keyboard.split()
    if not keyboard:
        pass
    if keyboard[0].lower() == 'exit':
        os.write(2, ('Exiting GoodShell.\n').encode())
        running = False
        sys.exit(0)
        break
    if keyboard[0] == 'cd':
        if len(keyboard) < 2:
            os.write(2, ('cd: no directory given').encode())
            sys.exit(0)
        else:
            try:
                os.chdir(os.path.abspath(keyboard[1]))
            except Exception:
                os.write(2, ('cd: no such file or directoy: {%s}' % (path))
            pass
    '''
    Make the child process with fork. One to keep the shell process, another to branch into commands.
    '''
    rc = os.fork()

    '''
    Handle fork failure. The error should be loud and prompt the user again.
    '''
    if rc < 0:
        os.write(2, ('Could not fork process. Error Code:\t%d' % rc).encode())
        sys.exit(-1)

    '''
    Hanle fork success. Child will carry 0 in rc variable so we branch in here.
    '''
    elif rc == 0:

        '''
        Handler for piping
        '''
        if '|' in keyboard:
            first_command, second_command = parse_pipe_command(keyboard)
            pipe_read, pipe_write = os.pipe()
            for fd in (pipe_read, pipe_write):
                os.set_inheritable(fd, True)

        '''
        Handler for redirections.
        '''
        if '>' in keyboard or '<' in keyboard:
            cmd_with_args, output_file, input_file = parse_command(keyboard)
            os.close(1) # cut off display from output
            os.open(output_file, os.O_CREAT | os.O_WRONLY) # open file
            os.set_inheritable(1, True)

        '''
        There are going to be two executes. One will pipe to another 
        '''
            os.close(1)
            os.dup(pipe_write)



        '''

        '''
        for dir in re.split(':', os.environ['PATH']):
            # Execute the commands given with exec()
            executable = '%s/%s' % (dir, keyboard[0])
            try:
                os.execve(executable, keyboard, os.environ)
            except FileNotFoundError:
                pass
        os.write(1, ('%s: command not found (gs)\n' % keyboard[0]).encode())
        sys.exit(-1)

    '''
    Parent part of fork handled here.
    '''
    else:
        # Wait until child process dies.
        wait_rc = os.wait()
