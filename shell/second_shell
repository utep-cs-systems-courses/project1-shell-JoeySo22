#! /usr/bin/env python3

import os, sys, re


def main():

    running = True

    while running:
        keyboard = input()
        if not keyboard:                      # No input
            pass
        if keyboard.strip() == 'exit':
            os.write(2, ('Exiting GoodShell\n'.encode()))
            running = False
            sys.exit(0)
            break

        '''
        Fork for midchild. Midchild handles the parsing and seperation of commands.
        '''
        mc_fork = os.fork()

        if mc_fork < 0:
            os.write(2, ('Could not fork process. Error code %d\n' % mc_fork).encode())
            sys.exit(-1)

        elif mc_fork == 0:
            if '|' in keyboard:
                cmd1, cmd2 = parse_pipe_command(keyboard)
                s_in = os.dup(0) #Save stdin for later, s_in is stacked in file descriptor
                s_out = os.dup(1) #Save stdout for later, s_out is also stacked
                fd_in = os.dup(s_in) #Variable for file descriptor input, created another to the stack

                #Without loop
                pipe_r, pipe_w = os.pipe()
                os.dup2(pipe_w, 1)
                running = exec_child_process(cmd1, True)
                os.dup2(pipe_r, 0)
                os.dup2(s_out, 1)
                running = exec_child_process(cmd2, False)
                os.dup2(s_in, 0)
                os.close(s_in)
                os.close(s_out)
                os.close(pipe_r)
                os.close(pipe_w)

                '''
                for command in (cmd1, cmd2):
                    os.dup2(fd_in, 0) #Set fd_in.
                    if command is cmd1:
                        fd_in, fd_out = os.pipe() #get new file descriptors by pipe
                        os.dup2(fd_out, 1)
                    else:
                        os.dup2(fd_in,0)
                        fd_out = os.dup(s_out) #set file descriptor to normal
                    os.dup2(fd_out, 1)
                    os.close(fd_out)

                    running = exec_child_process(cmd1, False)

                os.dup2(s_in, 0) #Restore the stdout and stdin
                os.dup2(s_out, 1)
                os.close(s_in)
                os.close(s_out)'''

            elif '<' in keyboard or '>' in keyboard:
                cmd_args, out_file, in_file = parse_rd_command(keyboard)
                s_out = os.dup(1) # save stdout for later to restore
                fd_fout = os.open(out_file, os.O_WRONLY | os.O_CREAT)
                os.dup2(fd_fout, 1)
                running = exec_child_process(cmd_args, False)
                os.dup2(s_out, 1)
                os.close(fd_fout)

            elif '&' is keyboard[-1]:
                os.write(1, ('[%s] %d\n' % (keyboard.split()[0], os.getpid())).encode())
                running = exec_child_process(keyboard[:-1], True)

            else: running = exec_child_process(keyboard, False)

        else:
            wait_p_fork = os.wait()


'''
Parse help from f20_os teams
'''
def parse_rd_command(cmd_string):
    out_file = None
    in_file = None
    cmd = ''

    cmd_string = re.sub(' +', ' ', cmd_string)

    if '>' in cmd_string:
        [cmd, out_file] = cmd_string.split('>', 1)
        out_file = out_file.strip()

    if '<' in cmd:
        [cmd, in_file] = cmd.split('<', 1)
        in_file = in_file.strip()

    elif out_file != None and '<' in out_file:
        [out_file, in_file] = out_file.split('<', 1)
        out_file = out_file.strip()
        in_file = in_file.strip()

    return cmd, out_file, in_file

def parse_pipe_command(cmd_string):
    if '|' in cmd_string:
        [first_cmd, second_cmd] = cmd_string.split('|', 1)
        first_cmd = first_cmd.strip()
        second_cmd = second_cmd.strip()
        return first_cmd, second_cmd
    else: return None, None

def exec_child_process(command, background):
    child_fork = os.fork()
    if child_fork < 0:
        os.write(2, ('Could not fork process. Error code %d\n' & child_fork).encode())
        sys.exit(-1)
    elif child_fork is 0:
        execute_command(command)
    else:
        if not background:
            child_wait_fork = os.wait()
        return False

def execute_command(cmd):
    cmd = cmd.split()
    for dir in re.split(':', os.environ['PATH']):
            # Execute the commands given with exec()
            executable = '%s/%s' % (dir, cmd[0])
            try:
                os.execve(executable, cmd, os.environ)
            except FileNotFoundError:
                pass
    os.write(1, ('%s: command not found (gs)\n' % cmd[0]).encode())
    sys.exit(-1)

main()
